// Generated by CoffeeScript 1.9.2
(function() {
  var ArrayList, Hashtable, HashtableBase, HashtableItemTypes, HashtableListTerminal, INT_SIZE, MAX_BYTES, MAX_BYTES_POW, STRING_ID, StringAlloc, StringClass, Strings, Struct, TDS, TDSArray, TypeArrays, TypeLenghts, Types, nTypes, names, namesCnt;

  nTypes = 6;

  Types = {
    Uint8: 0,
    Int32: 1,
    Int16: 2,
    Float32: 3,
    Float64: 4,
    String: 5
  };

  TypeArrays = [[Uint8Array, 1], [Int32Array, 1], [Int16Array, 1], [Float32Array, 1], [Float64Array, 1], [Int32Array, 2]];

  TypeLenghts = [1, 4, 2, 4, 8, 8];

  names = {};

  namesCnt = 1;

  STRING_ID = 0;

  INT_SIZE = 16;

  MAX_BYTES = 1 << 29;

  MAX_BYTES_POW = 29;

  Strings = {
    NO_PROPERTIES: function(name) {
      return "No properties in the struct " + name;
    }
  };

  StringAlloc = function() {
    var B, M, RES, StringClass, _addChar, _addView, buffer, charLens, chars, cleanup, create, i, i_lChar, i_lCharPos, i_lView, i_lViewPos, lastChar, lastCharLen, lastView, lastViewLen, m, release, retain, size, view, viewLens, viewPos, views;
    chars = [];
    charLens = [];
    lastChar = null;
    i_lChar = i_lCharPos = 0;
    lastCharLen = 0;
    views = [];
    viewLens = [];
    lastView = null;
    i_lView = i_lViewPos = 0;
    lastViewLen = 0;
    view = viewPos = 0;
    size = INT_SIZE;
    buffer = new ArrayBuffer(size << 1);
    chars.push(new Int16Array(buffer));
    charLens.push(size);
    lastChar = chars[0];
    lastCharLen = size;
    buffer = new ArrayBuffer(size * 16);
    views.push(new Array(4));
    for (i = m = 0; m < 4; i = ++m) {
      views[0][i] = new Int32Array(buffer, size * i * 4, size);
    }
    viewLens.push(size);
    lastView = views[0];
    lastViewLen = size;
    views[0][0][0] = -1;
    i_lViewPos = 1;
    create = function(str) {
      var len, q, ref;
      if (i_lViewPos === lastViewLen) {
        _addView();
      }
      if (i_lCharPos === lastCharLen) {
        _addChar();
      }
      len = str.length;
      lastView[0][i_lViewPos] = len;
      lastView[1][i_lViewPos] = i_lChar;
      lastView[2][i_lViewPos] = i_lCharPos;
      lastView[3][i_lViewPos] = 1;
      for (i = q = 0, ref = len; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
        if (i_lCharPos === lastCharLen) {
          _addChar();
        }
        lastChar[i_lCharPos++] = str.charCodeAt(i);
      }
      view = i_lView;
      viewPos = i_lViewPos;
      i_lViewPos++;
    };
    _addView = function() {
      var q;
      size = lastViewLen;
      if (size * 16 * 2 <= MAX_BYTES) {
        size = size << 1;
      }
      buffer = new ArrayBuffer(size * 16);
      lastView = new Array(4);
      views.push(lastView);
      for (i = q = 0; q < 4; i = ++q) {
        lastView[i] = new Int32Array(buffer, size * i * 4, size);
      }
      viewLens.push(size);
      lastViewLen = size;
      i_lViewPos = 0;
      return i_lView++;
    };
    _addChar = function() {
      size = lastCharLen;
      if (size * 2 * 2 <= MAX_BYTES) {
        size = size << 1;
      }
      buffer = new ArrayBuffer(size << 1);
      lastChar = new Int16Array(buffer);
      chars.push(lastChar);
      charLens.push(size);
      lastCharLen = size;
      i_lCharPos = 0;
      return i_lChar++;
    };
    retain = function(x, y) {
      return views[x][3][y]++;
    };
    release = function(x, y) {
      if (x === 0 && y === 0) {
        return;
      }
      views[x][3][y]--;
    };
    cleanup = function() {
      var cnt, iChar, iLen, ii, iiChar, iiLen, j, jj, len, moved, q, r, ref, ref1, skipped, x, xLen, xView, xx, xxLen, xxView, y, yy;
      i = j = 0;
      iLen = charLens[i];
      ii = jj = 0;
      iiLen = iLen;
      iChar = chars[i];
      iiChar = iChar;
      x = 0;
      y = 1;
      xLen = viewLens[x];
      xView = views[0];
      xx = x;
      yy = y;
      xxLen = xLen;
      xxView = xView;
      moved = skipped = 0;
      while (true) {
        if (y === i_lViewPos && x === i_lView) {
          break;
        }
        if (y === xLen) {
          y = 0;
          x++;
          xLen = viewLens[x];
          xView = views[x];
        }
        if (xView[3][y] === 0) {
          skipped++;
          len = xView[0][y];
          for (cnt = q = 0, ref = len; 0 <= ref ? q < ref : q > ref; cnt = 0 <= ref ? ++q : --q) {
            if (j === iLen) {
              j = 0;
              i++;
              iLen = charLens[i];
              iChar = chars[i];
            }
            j++;
          }
          y++;
        } else {
          if (yy === xxLen) {
            yy = 0;
            xx++;
            xxLen = viewLens[xx];
            xxView = views[xx];
          }
          moved++;
          len = xView[0][y];
          for (cnt = r = 0, ref1 = len; 0 <= ref1 ? r < ref1 : r > ref1; cnt = 0 <= ref1 ? ++r : --r) {
            if (j === iLen) {
              j = 0;
              i++;
              iLen = charLens[i];
              iChar = chars[i];
            }
            if (jj === iiLen) {
              jj = 0;
              ii++;
              iiLen = charLens[ii];
              iiChar = chars[ii];
            }
            iiChar[jj] = iChar[j];
            jj++;
            j++;
          }
          xxView[0][yy] = xView[0][y];
          xxView[1][yy] = xView[1][y];
          xxView[2][yy] = xView[2][y];
          xxView[3][yy] = xView[3][y];
          y++;
          yy++;
        }
      }
      console.log('Cleanup report');
      if (i_lView > xx) {
        views.splice(xx + 1);
        viewLens.splice(xx + 1);
      }
      console.log("new view: (" + xx + ", " + yy + ") old view: (" + i_lView + ", " + i_lViewPos + ")");
      i_lView = xx;
      i_lViewPos = yy;
      lastView = views[xx];
      lastViewLen = lastView[0].length;
      if (i_lChar > ii) {
        chars.splice(ii + 1);
        charLens.splice(ii + 1);
      }
      console.log("new char: (" + ii + ", " + jj + ") old char: (" + i_lChar + ", " + i_lCharPos + ")");
      i_lChar = ii;
      i_lCharPos = jj;
      lastChar = chars[ii];
      lastCharLen = lastChar.length;
      console.log("Garbage collection done");
      console.log(skipped + " strings are garbage collected");
      console.log(moved + " strings are moved");
    };
    B = 8191;
    M = 536870909;
    StringClass = (function() {
      function StringClass(str, x, y) {
        this.x = this.y = -1;
        if (str != null) {
          create(str);
          this.x = view;
          this.y = viewPos;
        } else if (x == null) {
          this.x = this.y = 0;
          retain(0, 0);
        } else {
          this.x = x;
          this.y = y;
          retain(x, y);
        }
        return;
      }

      StringClass.prototype.release = function() {
        return release(this.x, this.y);
      };

      StringClass.prototype.retain = function() {
        return retain(this.x, this.y);
      };

      StringClass.prototype.hash = function() {
        var b, c, char, clen, len, p, q, ref, res, str;
        len = views[this.x][0][this.y];
        if (len === -1) {
          return 0;
        }
        c = views[this.x][1][this.y];
        p = views[this.x][2][this.y];
        char = chars[c];
        clen = charLens[c];
        str = "";
        res = 0;
        b = 1;
        for (i = q = 0, ref = len; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          res = (b * char[p] + res) % M;
          b = (b * B) % M;
          p++;
          if (p === clen) {
            c++;
            char = chars[c];
            clen = charLens[c];
            p = 0;
          }
        }
        return res;
      };

      StringClass.prototype.equals = function(s) {
        var c1, c2, char1, char2, clen1, clen2, l1, l2, p1, p2, q, ref;
        l1 = views[this.x][0][this.y];
        l2 = views[s.x][0][s.y];
        if (l1 !== l2) {
          return false;
        } else if (l1 === -1) {
          return true;
        }
        c1 = views[this.x][1][this.y];
        p1 = views[this.x][2][this.y];
        c2 = views[s.x][1][s.y];
        p2 = views[s.x][2][s.y];
        char1 = chars[c1];
        char2 = chars[c2];
        clen1 = charLens[c1];
        clen2 = charLens[c2];
        for (i = q = 0, ref = l1; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          if (char1[p1] !== char2[p2]) {
            return false;
          }
          p1++;
          p2++;
          if (p1 === clen1) {
            c1++;
            p1 = 0;
            char1 = chars[c1];
            clen1 = charLens[c1];
          }
          if (p2 === clen2) {
            c2++;
            p2 = 0;
            char2 = chars[c2];
            clen2 = charLens[c2];
          }
        }
        return true;
      };

      StringClass.prototype.toString = function() {
        var c, char, clen, len, p, q, ref, str;
        len = views[this.x][0][this.y];
        if (len === -1) {
          return null;
        }
        c = views[this.x][1][this.y];
        p = views[this.x][2][this.y];
        char = chars[c];
        clen = charLens[c];
        str = "";
        for (i = q = 0, ref = len; 0 <= ref ? q < ref : q > ref; i = 0 <= ref ? ++q : --q) {
          str += String.fromCharCode(char[p]);
          p++;
          if (p === clen) {
            c++;
            char = chars[c];
            clen = charLens[c];
            p = 0;
          }
        }
        return str;
      };

      return StringClass;

    })();
    RES = {
      retain: retain,
      release: release,
      cleanup: cleanup,
      String: StringClass
    };
    return RES;
  };

  StringAlloc = StringAlloc();

  StringClass = StringAlloc.String;


  /*
  e.g.
  
  Person = TDS.Struct "Person",
   {property: "name", type: TDS.Types.String}
   {property: "address", type: TDS.Types.String, length: 3}
  
  p = new Person()
  console.log p.get()
   */

  Struct = function() {
    var RawObject, StructClass, bytes, code, fn, i, id, k, len1, lengths, m, maxBytesPerProp, n, name, offsets, properties, tcase, titleCasePropperties, types, v;
    id = null;
    name = null;
    properties = [];
    titleCasePropperties = [];
    types = [];
    lengths = [];
    offsets = [];
    n = 0;
    bytes = 0;
    maxBytesPerProp = 0;
    if (typeof arguments[0] !== 'string' || arguments[0].length === 0) {
      throw new Error('No name for the struct');
    }
    name = arguments[0];
    if (names[name] != null) {
      throw new Error("An Struct already defined with name: " + name);
    }
    names[name] = namesCnt;
    id = namesCnt++;
    for (k in arguments) {
      v = arguments[k];
      if (((v != null ? v.property : void 0) != null) && ((v != null ? v.type : void 0) != null) && (typeof v.property === 'string') && (typeof v.type === 'number') && v.type >= 0 && v.type < nTypes && (v.type === parseInt(v.type))) {
        properties.push(v.property);
        types.push(v.type);
        offsets.push(bytes);
        if ((v.length != null) && (typeof v.length === 'number') && (v.length > 0) && (v.length === parseInt(v.length))) {
          lengths.push(v.length);
          bytes += TypeLenghts[v.type] * v.length;
          maxBytesPerProp = Math.max(maxBytesPerProp, TypeLenghts[v.type] * v.length);
        } else {
          lengths.push(1);
          bytes += TypeLenghts[v.type];
          maxBytesPerProp = Math.max(maxBytesPerProp, TypeLenghts[v.type]);
        }
        n++;
      }
    }
    if (n === 0) {
      throw new Error(Strings.NO_PROPERTIES(name));
    }
    RawObject = (function() {
      function RawObject() {
        var i, len1, m;
        for (i = m = 0, len1 = properties.length; m < len1; i = ++m) {
          k = properties[i];
          if (lengths[i] === 1) {
            this[k] = null;
          } else {
            this[k] = new Array(lengths[i]);
          }
        }
      }

      return RawObject;

    })();
    StructClass = (function() {
      function StructClass(obj, views, pos, viewLen) {
        var buffer, i, len1, m, t;
        this.id = id;
        if (views != null) {
          this.views = views;
          this.pos = pos;
          this.viewLen = viewLen;
        } else {
          this.pos = 0;
          this.views = [];
          this.viewLen = 1;
          for (i = m = 0, len1 = types.length; m < len1; i = ++m) {
            t = types[i];
            buffer = new ArrayBuffer(TypeLenghts[t] * lengths[i]);
            this.views.push(new TypeArrays[t][0](buffer));
          }
        }
        if (obj != null) {
          this.set(obj);
        }
      }

      StructClass.prototype.set = function(obj) {
        var i, len1, m;
        if (obj != null) {
          for (i = m = 0, len1 = properties.length; m < len1; i = ++m) {
            k = properties[i];
            if (obj[k] != null) {
              this.set_prop(i, obj[k]);
            }
          }
        }
      };

      StructClass.prototype.get = function() {
        var i, len1, m, o;
        o = new RawObject();
        for (i = m = 0, len1 = properties.length; m < len1; i = ++m) {
          k = properties[i];
          o[k] = this.get_prop(i);
        }
        return o;
      };

      StructClass.prototype.set_prop = function(v, i, j, string_ref) {
        var k1, l, m, q, ref, ref1, s;
        if (types[i] === Types.String) {
          if (lengths[i] === 1) {
            if (string_ref === true) {
              s = v;
              s.retain();
            } else {
              s = new StringClass(v);
            }
            StringAlloc.release(this.views[i][this.pos * 2], this.views[i][this.pos * 2 + 1]);
            this.views[i][this.pos * 2] = s.x;
            this.views[i][this.pos * 2 + 1] = s.y;
          } else {
            k1 = this.pos * lengths[i] * 2;
            if (j != null) {
              if (string_ref === true) {
                s = v;
                s.retain();
              } else {
                s = new StringClass(v);
              }
              StringAlloc.release(this.views[i][k1 + j * 2], this.views[i][k1 + j * 2 + 1]);
              this.views[i][k1 + j * 2] = s.x;
              this.views[i][k1 + j * 2 + 1] = s.y;
            } else {
              l = Math.min(lengths[i], v.length);
              for (j = m = 0, ref = l; 0 <= ref ? m < ref : m > ref; j = 0 <= ref ? ++m : --m) {
                if (string_ref === true) {
                  s = v;
                  s.retain();
                } else {
                  s = new StringClass(v[j]);
                }
                StringAlloc.release(this.views[i][k1 + j * 2], this.views[i][k1 + j * 2 + 1]);
                this.views[i][k1 + j * 2] = s.x;
                this.views[i][k1 + j * 2 + 1] = s.y;
              }
            }
          }
        } else {
          if (lengths[i] === 1) {
            this.views[i][this.pos] = v;
          } else {
            k1 = this.pos * lengths[i];
            if (j != null) {
              this.views[i][k1 + j] = v;
            } else {
              l = Math.min(lengths[i], v.length);
              for (j = q = 0, ref1 = l; 0 <= ref1 ? q < ref1 : q > ref1; j = 0 <= ref1 ? ++q : --q) {
                this.views[i][k1 + j] = v[j];
              }
            }
          }
        }
      };

      StructClass.prototype.get_prop = function(i, j, string_ref) {
        var k1, m, q, ref, ref1, res, s;
        res = null;
        if (lengths[i] === 1) {
          if (types[i] === Types.String) {
            s = new StringClass(null, this.views[i][this.pos * 2], this.views[i][this.pos * 2 + 1]);
            if (string_ref === true) {
              res = s;
            } else {
              res = s.toString();
              s.release();
            }
          } else {
            res = this.views[i][this.pos];
          }
        } else {
          if (j != null) {
            if (types[i] === Types.String) {
              k1 = this.pos * lengths[i] * 2;
              s = new StringClass(null, this.views[i][k1 + j * 2], this.views[i][k1 + j * 2 + 1]);
              if (string_ref === true) {
                res = s;
              } else {
                res = s.toString();
                s.release();
              }
            } else {
              k1 = this.pos * lengths[i];
              res = this.views[i][k1 + j];
            }
          } else {
            res = new Array(lengths[i]);
            if (types[i] === Types.String) {
              k1 = this.pos * lengths[i] * 2;
              for (j = m = 0, ref = lengths[i]; 0 <= ref ? m < ref : m > ref; j = 0 <= ref ? ++m : --m) {
                s = new StringClass(null, this.views[i][k1 + j * 2], this.views[i][k1 + j * 2 + 1]);
                if (string_ref === true) {
                  res[j] = s;
                } else {
                  res[j] = s.toString();
                  s.release();
                }
              }
            } else {
              k1 = this.pos * lengths[i];
              for (j = q = 0, ref1 = lengths[i]; 0 <= ref1 ? q < ref1 : q > ref1; j = 0 <= ref1 ? ++q : --q) {
                res[j] = this.views[i][k1 + j];
              }
            }
          }
        }
        return res;
      };

      StructClass.prototype.copyFrom = function(struct) {
        var i, j, k1, k2, len1, m, p, q, r, ref, ref1, t;
        if (this.id !== struct.id) {
          return false;
        }
        for (i = m = 0, len1 = types.length; m < len1; i = ++m) {
          t = types[i];
          k1 = lengths[i] * TypeArrays[t][1];
          k2 = TypeArrays[t][1];
          for (j = q = 0, ref = lengths[i]; 0 <= ref ? q < ref : q > ref; j = 0 <= ref ? ++q : --q) {
            p = this.pos * k1 + j * k2;
            if (t === Types.String) {
              StringAlloc.release(this.views[i][p], this.views[i][p + 1]);
            }
            for (k = r = 0, ref1 = k2; 0 <= ref1 ? r < ref1 : r > ref1; k = 0 <= ref1 ? ++r : --r) {
              this.views[i][p + k] = struct.views[i][struct.pos * k1 + j * k2 + k];
            }
            if (t === Types.String) {
              StringAlloc.retain(this.views[i][p], this.views[i][p + 1]);
            }
          }
        }
        return true;
      };

      StructClass.prototype.next = function() {
        if (this.pos < this.viewLen - 1) {
          this.pos++;
          return true;
        } else {
          return false;
        }
      };

      StructClass.prototype.prev = function() {
        if (this.pos > 0) {
          this.pos--;
          return true;
        } else {
          return false;
        }
      };

      return StructClass;

    })();
    fn = function(i) {
      StructClass.prototype["set" + tcase] = function(val, j, string_ref) {
        return this.set_prop(val, i, j, string_ref);
      };
      return StructClass.prototype["get" + tcase] = function(j, string_ref) {
        return this.get_prop(i, j, string_ref);
      };
    };
    for (i = m = 0, len1 = properties.length; m < len1; i = ++m) {
      k = properties[i];
      StructClass[k.toUpperCase()] = i;
      code = k.charCodeAt(0);
      tcase = k;
      if (code <= 122 && code >= 97) {
        tcase = (k.substr(0, 1)).toUpperCase() + k.substr(1);
      }
      titleCasePropperties.push(tcase);
      fn(i);
    }
    StructClass.id = id;
    StructClass.name = name;
    StructClass.properties = properties;
    StructClass.titleCasePropperties = titleCasePropperties;
    StructClass.types = types;
    StructClass.lengths = lengths;
    StructClass.offsets = offsets;
    StructClass.n = n;
    StructClass.bytes = bytes;
    StructClass.maxBytesPerProp = maxBytesPerProp;
    StructClass.Object = RawObject;
    return StructClass;
  };

  TDSArray = function(struct, length) {
    var ArrayClass, views;
    views = null;
    ArrayClass = (function() {
      function ArrayClass() {
        var buffer, i, len1, m, ref, t;
        this.struct = struct;
        this.length = length;
        views = [];
        ref = struct.types;
        for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
          t = ref[i];
          buffer = new ArrayBuffer(TypeLenghts[t] * struct.lengths[i] * length);
          views.push(new TypeArrays[t][0](buffer));
        }
      }

      ArrayClass.prototype.get = function(i, structIns) {
        if (structIns != null) {
          structIns.views = views;
          structIns.pos = i;
        } else {
          structIns = new struct(null, views, i, length);
        }
        return structIns;
      };

      ArrayClass.prototype.getViews = function() {
        return views;
      };

      ArrayClass.prototype.release = function() {
        var i, j, k1, k2, len1, m, p, pos, q, ref, ref1, t;
        ref = struct.types;
        for (i = m = 0, len1 = ref.length; m < len1; i = ++m) {
          t = ref[i];
          if (t === Types.String) {
            k1 = struct.lengths[i] * TypeArrays[t][1];
            k2 = TypeArrays[t][1];
            pos = i * k1;
            for (j = q = 0, ref1 = struct.lengths[i]; 0 <= ref1 ? q < ref1 : q > ref1; j = 0 <= ref1 ? ++q : --q) {
              p = pos + j * k2;
              StringAlloc.release(views[i][p], views[i][p + 1]);
            }
          }
        }
      };

      return ArrayClass;

    })();
    return new ArrayClass;
  };

  ArrayList = function(struct, start_size) {
    var ArrayListClass, arrays, i, i_lArr, i_lArrPos, lastArr, length, m, max_size, ref, size, t;
    arrays = null;
    length = 0;
    lastArr = null;
    i_lArr = i_lArrPos = 0;
    size = null;
    max_size = Math.floor(MAX_BYTES / struct.maxBytesPerProp);
    t = 0;
    for (i = m = 0, ref = MAX_BYTES_POW; 0 <= ref ? m <= ref : m >= ref; i = 0 <= ref ? ++m : --m) {
      if ((max_size & (1 << i)) > 0) {
        t = i;
      }
    }
    max_size = 1 << t;
    t = null;
    ArrayListClass = (function() {
      function ArrayListClass() {
        arrays = this.arrays = [];
        this.struct = struct;
        if (start_size == null) {
          start_size = 0;
        }
        size = INT_SIZE;
        while (size < start_size && (size << 1) <= max_size) {
          size = size << 1;
        }
        length = 0;
        while (true) {
          lastArr = TDSArray(struct, size);
          arrays.push(lastArr);
          if (length + size >= start_size) {
            i_lArrPos = start_size - length;
            length = this.length = start_size;
            break;
          } else {
            i_lArr++;
            length += size;
          }
        }
      }

      ArrayListClass.prototype.get = function(p, structIns) {
        var x, y;
        if (p < 0 || p >= length) {
          return null;
        }
        x = Math.floor(p / size);
        y = p % size;
        return arrays[x].get(y, structIns);
      };

      ArrayListClass.prototype.add = function(structIns) {
        if (i_lArrPos === size) {
          this._addArray();
        }
        this.length++;
        length++;
        return lastArr.get(i_lArrPos++, structIns);
      };

      ArrayListClass.prototype._addArray = function() {
        var j, q, r, ref1, ref2, tarViews, views;
        if (size < max_size) {
          views = lastArr.getViews();
          lastArr = TDS.Array(struct, size << 1);
          tarViews = lastArr.getViews();
          for (j = q = 0, ref1 = views.length; 0 <= ref1 ? q < ref1 : q > ref1; j = 0 <= ref1 ? ++q : --q) {
            for (i = r = 0, ref2 = views[j].length; 0 <= ref2 ? r < ref2 : r > ref2; i = 0 <= ref2 ? ++r : --r) {
              tarViews[j][i] = views[j][i];
            }
          }
          tarViews = null;
          views = null;
          arrays[0].release();
          arrays[0] = lastArr;
          i_lArrPos = size;
          return size = size << 1;
        } else {
          lastArr = TDS.Array(struct, size);
          arrays.push(lastArr);
          i_lArr++;
          return i_lArrPos = 0;
        }
      };

      return ArrayListClass;

    })();
    return new ArrayListClass;
  };

  HashtableListTerminal = Struct("__ListTerminal__", {
    property: 'start',
    type: Types.Float64
  }, {
    property: 'end',
    type: Types.Float64
  });

  HashtableItemTypes = {};

  HashtableBase = function(size, val_type) {
    var HashtableBaseClass, ItemType, ListTerminal, ii, items, li, lists;
    if (val_type == null) {
      val_type = Types.Int32;
    }
    ListTerminal = HashtableListTerminal;
    if (HashtableItemTypes[val_type] != null) {
      ItemType = HashtableItemTypes[val_type];
    } else {
      ItemType = HashtableItemTypes[val_type] = Struct("__ItemType__" + val_type, {
        property: 'key',
        type: Types.String
      }, {
        property: 'hash',
        type: Types.Int32
      }, {
        property: 'val',
        type: val_type
      }, {
        property: 'next',
        type: Types.Float64
      });
    }
    lists = new ArrayList(ListTerminal, size);
    items = new ArrayList(ItemType, null);
    li = ii = null;
    HashtableBaseClass = (function() {
      function HashtableBaseClass() {
        var i, m, ref;
        li = lists.get(0);
        for (i = m = 0, ref = size; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
          li.setStart(-1);
          li.setEnd(-1);
          if (!li.next()) {
            li = lists.get(i + 1, li);
          }
        }
      }

      HashtableBaseClass.prototype.set = function(key, val, string_ref) {
        var end, hash, pos, s, ss, start;
        if (string_ref) {
          s = key;
          s.retain();
        } else {
          key = "" + key;
          s = new StringClass(key);
        }
        hash = s.hash();
        pos = hash % size;
        li = lists.get(pos, li);
        end = li.getEnd();
        if (end === -1) {
          li.setStart(items.length);
          li.setEnd(items.length);
          this._addItem(s, hash, val);
        } else {
          start = li.getStart();
          while (start !== -1) {
            ii = items.get(start, ii);
            if (ii.getHash() === hash) {
              ss = ii.getKey(null, true);
              if (ss.equals(s)) {
                ss.release();
                ii.setVal(val);
                break;
              }
              ss.release();
            }
            start = ii.getNext();
          }
          if (start === -1) {
            ii.setNext(items.length);
            li.setEnd(items.length);
            this._addItem(s, hash, val);
          }
        }
        s.release();
      };

      HashtableBaseClass.prototype._addItem = function(s, hash, val) {
        ii = items.add(ii);
        ii.setKey(s, null, true);
        ii.setHash(hash);
        ii.setVal(val);
        ii.setNext(-1);
      };

      HashtableBaseClass.prototype.get = function(key, string_ref) {
        var hash, pos, res, s, ss, start;
        if (string_ref) {
          s = key;
          s.retain();
        } else {
          key = "" + key;
          s = new StringClass(key);
        }
        hash = s.hash();
        pos = hash % size;
        li = lists.get(pos, li);
        start = li.getStart();
        res = null;
        while (start !== -1) {
          ii = items.get(start, ii);
          if (ii.getHash() === hash) {
            ss = ii.getKey(null, true);
            if (ss.equals(s)) {
              ss.release();
              res = ii.getVal();
              break;
            }
            ss.release();
          }
          start = ii.getNext();
        }
        s.release();
        return res;
      };

      HashtableBaseClass.prototype.summarize = function() {
        var cnt, i, m, ref;
        li = lists.get(0, li);
        cnt = 0;
        for (i = m = 0, ref = size; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
          if (li.getStart() === -1) {
            cnt++;
          }
          if (!li.next()) {
            li = lists.get(i + 1, li);
          }
        }
        console.log('Hastable summarry');
        return console.log("lists with no items: " + cnt + " out of " + size);
      };

      return HashtableBaseClass;

    })();
    return new HashtableBaseClass;
  };

  Hashtable = function(size, struct) {
    var HashtableClass, base, items, length, val_type;
    val_type = Types.Float64;
    items = new ArrayList(struct, null);
    base = HashtableBase(size, val_type);
    length = 0;
    HashtableClass = (function() {
      function HashtableClass() {}

      HashtableClass.prototype.get = function(key, structIns, string_ref) {
        var val;
        val = base.get(key, string_ref);
        if (val == null) {
          base.set(key, length++, string_ref);
          return items.add(structIns);
        }
        return items.get(val, structIns);
      };

      HashtableClass.prototype.check = function(key, string_ref) {
        var val;
        val = base.get(key, string_ref);
        if (val == null) {
          return false;
        } else {
          return true;
        }
      };

      return HashtableClass;

    })();
    return new HashtableClass();
  };

  TDS = {
    Types: Types,
    Struct: Struct,
    String: StringClass,
    cleanup: function() {
      return StringAlloc.cleanup();
    },
    Array: TDSArray,
    ArrayList: ArrayList,
    HashtableBase: HashtableBase,
    Hashtable: Hashtable
  };

  if (typeof GLOBAL !== "undefined" && GLOBAL !== null) {
    module.exports = TDS;
  } else {
    window.TDS = TDS;
  }

}).call(this);
